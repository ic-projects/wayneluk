Individual Reflection
=====================

Imperial Login : js4416

Group Name : WayneLuk

Guidance
--------

The aim is to get you to think about specific things that you
have learnt, or things that went well or less well. For each
of the areas identified below, write (at most) 100 words on how
well that area went. Examples of things that you might address
are:

- Some kind of concept or approach that became clearer

- A skill or tool that you found useful

- Identifying where some choices were poor

- A change in approach that improved your solution

- Changes in strategy that could help in future projects



You should identify things specific to you and this coursework,
not just general things, and link them to specific features or
activities of the coursework. In some cases you may want to refer
to classes, functions, or source files in your submission,
and/or highlight specific commits (e.g. by hash) in order to
show changes.

For example, these is quite generic and doesn't tell us anything:

> I learnt how to use classes more effectively.

> I hadn't used the command line much before, and now have got used to it.

Whereas these are more specific (don't use these as a template, you
have to word):

> Originally I wasn't sure how to map part A of the simulator into
> structs, so I originally thought about mapping each B to an
> struct. However, this turned out to be the wrong approach
> because C, so we ended up using D.

> I suggested that we use method A to build the testbench, as I
> thought it would have benefit B. While it worked well enough,
> in future I might choose to do C, because D.

There is no "right" answer, and there is no particular
requirement on how "big" each thing is, either in concept
size or the number of words. There is also no bias towards
whether a strength or weakness is better - either could be
relevant. The only requirements are that the answers should be:

- Specific to you

- Specific to this coursework

- Be some sort of genuine reflection on your practise

- Related to the specific topic

This will be assessed, and is not just a tick box exercise.

Submission
----------

This should be submitted individually via blackboard (not
via the group repo).

Group working
-------------

In previous group assignments, we have always worked in groups of 4, 6 or more.

It quickly became clear that approaches that are absolutely necessary in large groups,
such as using feature branches in Git, were not necessary when working in a pair,
and were actually wasting a lot more time than they were saving.

What was actually much more important was continuous communication to make sure
I knew what Pranav was doing and vice versa. With only two people, this was
relatively easy and allowed us to get rid of the overhead of
scrum boards, feature branching etc.

Time management
---------------

I think our group's time management skills were good. We agreed to set
aside an entire weekend before the formative to complete a significant
chunk of the project - aiming to set up the infrastructure for the
simulator and testbench, and support basic instructions.

Although it was difficult to find a time that worked, our
approach was successful, as we were physically in the same room and
had no other distractions.

This meant that we could concentrate fully and provide help when we were blocked,
which made development efficient. Being able to discuss ideas and collaborate
easily also improved our design.

Software skills (e.g. debugging, design, coding)
------------------------------------------------

Our original design was too complex. We had an `Instruction` class, with an abstract
`execute(CPU)` method, and three implementations (J/I/R). However, in order to execute
an instruction, you need access to registers and memory, so it makes more sense
to have an `execute(Instruction)` method for `CPU` than an `executeWithCPU(CPU)`
method for `Instruction`.

We minimised duplication by extracting common functionality into methods,
but some code, such as mapping opcodes to instructions, was repetitive.
We autogenerated these parts, which was quicker than writing it out ourselves.

With hindsight, I would also write a script to autogenerate tests
based on patterns and tables of inputs, rather than writing sources by hand.

Tools and Infrastructure (e.g. OS, automation, ...)
---------------------------------------------------

My machine runs Ubuntu 18.04 and Pranav's runs OSX.
The different software versions were causing conflicts and build issues,
so we moved to virtualised installations of Ubuntu 16.04.

We quickly realised that using `make` was slowing us down, as we are both CLion
users, which uses `cmake` by default. Our `cmake` config was both easier to update
and run directly from the IDE, and a short script made it just as easy to use in
a terminal.

I would use continuous integration in future projects to check that we don't
introduce new bugs to existing code.

Understanding of computer architecture
--------------------------------------

The one thing that really tripped us up was branch delays:
we were somewhat confused when the MIPS assembler was
re-ordering our branch instructions. This led us to read up on pipelining in MIPS,
giving us a better understanding on how pipelined datapaths work, compared
to the single-cycle datapath that we had seen in lectures.

Having written an ARM emulator in first year, the importance of a simple ISA,
with a few common formats became clearer to me.

I also discovered, when assembling tests, how useful pseudo-instructions are
for making programs easy to write without having to implement many instructions.
